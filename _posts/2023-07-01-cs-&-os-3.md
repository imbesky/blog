---
title: "[컴퓨터구조&운영체제] 3. 명령어"
excerpt: "명령어"

categories:
  - Concept
tags:
  - [concept, CS&OS]

permalink: /concept/cs-&-os-3/

toc: true
toc_sticky: true

date: 2023-07-01
last_modified_at: 2023-10-22
---
# 3. 명령어 

## 소스 코드와 명령어
모든 소스 코드는 컴퓨터 내부에서 명령어로 변환됨 

### 고급 언어, 저급 언어
1. 고급 언어 high-level programming language
- 사람의 이해와 작성을 위해 만들어진 언어
- 대부분의 프로그래밍 언어가 여기 속함 

2. 저급 언어
- 컴퓨터가 직접 이해하고 실행할 수 있는 언어
- 명령어로 이루어져 있음
- 고급 언어로 작성된 소스 코드가 실행되려면 반드시 저급 언어, 즉 명령어로 변환되어야 함
- 기계어와 어셈블리어로 나뉨 

기계어 machine code
- 0과 1의 명령어 비트로 이루어진 언어(명령어 모음)
- 사람은 이해하기 어려움 

어셈블리어 assembly language
- 기계어를 읽기 편한 형태로 번역한 언어 

### 컴파일 언어, 인터프리터 언어
고급 언어로 작성한 소스 코드는 저급 언어로 변환되어 실행됨
변환 방식에 따라 두 가지 언어로 나뉨 

1. 컴파일 언어
컴파일 방식으로 작동하는 프로그래밍 언어
반드시 하나의 방식으로만 작동하는 것은 아님 

- 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행됨
- C
- 소스 코드 내에 오류가 하나라도 있으면 컴파일에 실패함
- 목적 코드 object code: 컴파일러를 통해 저급 언어로 변환된 코드 

2. 인터프리터 언어
인터프리트 방식으로 작동하는 프로그래밍 언어 

- 인터프리터에 의해 소스 코드가 한 줄씩 실행됨
- python
- 소스 코드 전체를 저급 언어로 변환하는 대기 시간이 없음
- 오류가 있더라도 이전 줄까지는 올바르게 수행됨 

3. 속도 차이
일반적으로 인터프리터 언어는 컴파일 언어보다 느림
목적 코드는 컴퓨터가 바로 이해하고 실행 가능한 저급 언어인 반면, 인터프리터 언어는 소스 코드 마지막 줄까지 하나씩 해석하고 실행해야 하기 때문 

### 목적 파일, 실행 파일
1. 목적 파일
목적 코드로 이루어진 파일 

2. 실행 파일
실행 코드로 이루어진 파일
- .exe 확장자를 가진 파일 

3. 변환
목적 코드가 실행 파일이 되기 위해서는 링킹을 거쳐야 함
- 링킹: 파일들끼리 연결해주는 작업
- 기능을 담을 파일과 그 기능을 사용한 파일을 연결해주는 등의 작업 

## 명령어의 구조 

### 명령어 = 연산 코드 + 오퍼랜드
1. 연산 코드 operation code
명령어가 수행할 연산
- 연산자
- 1) 데이터 전송: MOV, PUSH, POP
- 2) 산술 논리 연산: ADD, OR, CMP
- 3) 제어 흐름 변경: JMP, CALL, RET
- 4) 입출력 제어: START IO, WRITE 

2. 오퍼랜드 operand
연산에 사용할 데이터가 저장된 위치
- 피연산자
- 보통 데이터가 저장된 위치인 메모리 주소나 레지스터 이름이 담김
- 따라서 주소 필드라고도 불림
- 명령어를 '오퍼랜드개수-주소 명령어'의 형태로 부르기도 함 

### 주소 지정 방식 addressing mode
오퍼랜드 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법
- 보통 명령어의 길이 때문에 최대한 많은 정보를 담기 위해 오퍼랜드 필드에 주소를 담음
- 유효 주소 effective address: 연산의 대상이 되는 데이터가 저장된 위치 

1. 즉시 주소 지정 방식 immediate addressing mode
연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 표현할 수 있는 데이터의 크기가 작아짐
- 빠름; 연산에 사용할 데이터를 메모리나 레지스터로부터 찾지 않음 

2. 직접 주소 지정 방식 direct addressing mode
오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수만큼 짧아져 표현량에 제한이 있음 

3. 간접 주소 지정 방식 indirect addressing mode
유효 주소의 주소를 오퍼랜드 필드에 명시
- 두 번의 메모리 접근이 필요해 상대적으로 느림 

4. 레지스터 주소 지정 방식 register addressing mode
사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시
- CPU 외부에 있는 메모리보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠름
- 즉 직접 주소 지정 방식보다 빠르게 데이터에 접근 가능
- 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음 

5. 레지스터 간접 주소 지정 방식 register indirect addressing mode
연산에 사용할 데이터를 메모리에 저장하고 그 유효 주소를 저장한 레지스터를 오퍼랜드 필드에 명시
- 메모리에 접근하는 횟수가 한 번으로 줄어 간접 주소 지정 방식보다 빠름 

### 스택과 큐
스택과 큐는 다음 게시글에서 정리했음
[게시글로 이동](https://imbesky.github.io/pages/imbesky/concept/datastructure-and-algorithm-5/)