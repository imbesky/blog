---
title: "[컴퓨터구조&운영체제] 10. 프로세스와 스레드"
excerpt: "프로세스와 스레드"

categories:
  - Concept
tags:
  - [concept, CS&OS]

permalink: /concept/cs-&-os-10/

toc: true
toc_sticky: true

date: 2023-12-21
last_modified_at: 2023-12-21
---
# 10. 프로세스와 스레드

## 1. 프로세스 개요

프로세스: 실행 중인 프로그램

- 프로그램은 실행 이전까지는 보조기억장치의 데이터
- 프로세스 생성: 보조기억장치에 저장된 프로그램을 메모리에 적재하고 실행하는 과정

### 프로세스의 확인

윈도우에서 `작엄 관리자` -> `프로세스` 탭에서 확인 가능

1. foreground process: 사용자가 볼 수 있는 공간에서 실행되는 프로세스
2. background process: 사용자가 볼 수 없는 공간에서 실행되는 프로세스
  - 사용자와 상호작용할 수 없는 프로세스: daemon(유닉스), service(윈도우)

### 프로세스 제어 블록 Process Control Block

- 모든 프로세스는 실행을 위해 CPU를 필요로 함
- CPU 자원은 한정되어 있기에 돌아가며 한정된 시간만큼 CPU를 이용
- 시간이 끝나면 타이머 인터럽트가 발생

번갈아 수행되는 프로세스의 실행 순서를 관리하고 CPU를 비롯한 자원을 배분하는 운영체제

- 프로세스 식별 등 프로세스와 관련된 정보를 저장하는 자료 구조
- 커널 영역에 생성됨
- 프로세스 생성 시에 만들어지고 실행 후 폐기됨

#### 저장되는 정보

1. 프로세스 ID
  - 특정 프로세스를 식별하기 위해 부여하는 고유한 번호
  - 실행 때마다 다른 PID 부여

2. 레지스터 값
  -자신의 실행 차례가 돌아온 프로세스는 이전까지 사용했던 레지스터의 중간값 복원
  - 프로그램 카운터를 비롯한 레지스터의 값들

3. 프로세스 상태

4. CPU 스케줄링 정보

5. 메모리 관리 정보
  - 프로세스가 어느 주소에 저장되어 있는지
  - 페이지 테이블 정보; 프로세스의 주소를 알기 위한 정보
  - 베이스 레지스터, 한계 레지스터 등

6. 사용한 파일과 입출력장치 목록

### 문맥 겨환

문맥 context: 하나의 프로세스 수행을 재개하기 위해 기억해야 하는 정보

- 하나의 프로세스 문맥은 해당 프로세스의 PCB에 표현되어 있음
- PCB에 기록되는 정보들을 문맥이라고 봐도 무방
- 레지스터 값, 메모리 정보, 사용한 파일과 입출력장치 목록 등의 정보
- 인터럽트가 발생하면 운영체제는 해당 프로세스의 PCB에 문맥을 백업
- 프로세스 실행시 문맥을 복구

#### 문맥 교환 context switching

기존 프로세스의 문맥을 PCB에 백업하고 새로운 프로세스를 실행하기 위한 문맥을 PCB로부터 복구하여 새로운 프로세스를 실행하는 것

### 프로세스의 메모리 영역(segment)

사용자 영역의 구분; 코드 / 데이터 / 힙 / 스택 영역

- 정적 할당 영역: 크기가 고정되어 있는 코드 영역, 데이터 영역
- 동적 할당 영역: 크기가 가변적인 힙 영역, 스택 영역
  - 힙 영역은 낮은 주소 -> 높은 주소
  - 스택 영역은 높은 주소 -> 낮은 주소
  - 할당되는 주소의 중복을 막기 위함

#### 1) 코드 영역

= 텍스트 영역

기계어로 이루어진 명령어 저장

- read only
- CPU가 실행할 명령어

#### 2) 데이터 영역

프로그램이 실행되는 동안 유지할 데이터

- global variable 등

#### 3) 힙 영역

사용자가 직접 할당할 수 있는 저장 공간

- 힙 영역에 메모리 공간을 할당했다면 언젠가 다시 반환해야 함
  - 메모리 공간의 반환 = 해당 메모리 공간을 사용하지 않는다고 운영체제에 전달하는 것
- 메모리 누수: 메모리 공간을 반환하지 않아 초래되는 메모리 낭비

#### 4) 스택 영역

데이터를 일시적으로 저장하는 공간

- 매개 변수, 지역 변수 등

## 2. 프로세스 상태와 계층 구조

- 프로세스는 저마다의 상태가 있음; 실행 중, 일시 중단 등
- 운영체제는 프로세스의 상태를 PCB에 기록해 계층적으로 관리

### 프로세스 상태

#### 생성 상태 new

프로세스를 상생 중인 상태

- 메모리에 적재되어 PCB를 할당받은 상태
- 실행 준비가 완료된 프로세스는 곧바로 실행되지 않고 준비 상태가 되어 CPU 할당 대기

#### 준비 상태 ready

CPU를 할당받아 실행할 수 있으나 차례가 오지 않아 기다리는 상태

#### 실행 상태 running

CPU를 할당받아 실행 중인 상태

- 할당된 일정 시간 동안만 CPU 사용 가능
- 타이머 인터럽트가 발생하면 다시 준비 상태가 됨
- 실행 도중 입출력장치를 사용해 입출력장치의 작업이 끝날 때까지 기다려야 한다면 대기 상태가 됨

#### 대기 상태 blocked

프로세스 실행 도중 입출력장치를 사용해 입출력장치의 작업을 기다리는 상태 

- 입출력 작업은 CPU에 비해 작업 속도가 느려 입출력 작업을 요청한 프로세스는 입출력 완료 인터럽트를 받을 때까지 기다려야 함
- 입출력 작업이 완료되면 해당 프로세스는 다시 준비 상태로 CPU 할당 기다림

#### 종료 상태 terminated

프로세스가 종료된 상태

- 운영체제는 PCB와 프로세스가 사용한 메모리 정리

#### 프로세스 상태 다이어그램

[사진보기](https://www.google.com/search?q=%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4+%EC%83%81%ED%83%9C+%EB%8B%A4%EC%9D%B4%EC%96%B4%EA%B7%B8%EB%9E%A8&sca_esv=592829625&tbm=isch&source=lnms&sa=X&ved=2ahUKEwjtpIzQ2KCDAxV7hVYBHfOOCNUQ_AUoAXoECAEQAw&biw=1680&bih=923&dpr=1#imgrc=uE_tjU9wOtEhYM)

### 프로세스 계층 구조

프로세스는 실행 도중 시스템 호출을 통해 다른 프로세스 생성 가능

- 부모 프로세스: 새 프로세스를 생성한 프로세스
- 자식 프로세스: 부모 프로세스에 의해 생성된 프로세스

- 별개의 프로세스이기 때문에 다른 PID 가짐
- 일부 운영 체제에서는 자식 프로세스의 PCB에 부모 프로세스의 PID인 PPID 기록

- 자식 프로세스가 또다른 자식 프로세스 생성 가능
- 많은 운영체제는 프로세스 계층 구조로 프로세스 관리

### 프로세스 생성 기법

시스템 호출의 일종인 `fork`와 `exec` 사용

#### fork

부모 프로세스가 자신의 복사본으로 자식 프로세스를 생성하는 방식

- 자기 자신 프로세스의 복사본을 만드는 시스템 호출
- 메모리 내용, 열린 파일 목록 등이 상속됨

#### exec

만들어진 복사본인 자식 프로세스가 자신의 메모리 공간을 다른 프로그램으로 교체하는 방식

- 자신의 메모리 공간을 새로운 프로그램으로 덮어쓰는 시스템 호출
- 새로운 프로그램 내용으로 전환해 실행
- 코드 영역과 데이터 영역의 내요잉 실행할 프로그램으로 바뀌고 나머지 영역은 초기화됨

#### fork 후 exec를 호출하지 않는 경우

부모 프로세스와 자식 프로세스는 같은 코드를 병행하여 실행하는 프로세스가 됨

