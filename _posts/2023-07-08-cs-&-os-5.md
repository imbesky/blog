---
title: "[컴퓨터구조&운영체제] 5. CPU 성능 향상 기법"
excerpt: "CPU 성능 향상 기법"

categories:
  - Concept
tags:
  - [concept, CS&OS]

permalink: /concept/cs-&-os-5/

toc: true
toc_sticky: true

date: 2023-07-08
last_modified_at: 2023-11-21
---
# [컴구운체] 5. CPU 성능 향상 기법 

## 1. 빠른 CPU를 위한 설계 기법 

CPU 속도와 관계 있는 개념들 

### 클럭 

CPU에서 사용하는 시간 단위 

- 클럭 속도 단위: Hz = 클럭/s
- 클럭 속도와 CPU 속도가 반드시 비례하는 것은 아님
- 클럭 속도를 높이면 발열 문제가 생김 

### 코어, 멀티코어 

CPU 내부의 `명령어를 실행하는 부품`

- 전통적으로는 한 CPU 내부에 하나만 존재했으나 기술의 발전으로 여러 개로 늘어남
- 멀티코어 CPU = 멀티코어 프로세서: 코어를 여러 개 포함한 CPU
- single, dual, triple, quad, hexa, octa, daca, dodeca ...
- 코어 수 증가와 CPU 연산 속도가 반드시 비례하는 것은 아님
- 코어마다 처리하는 연산이 적절히 분배되어야 함 

### 스레드, 멀티스레드 

`thread`: 실행 흐름의 단위 

#### 하드웨어적 스레드 = 논리 프로세서 

하나의 코어가 동시에 처리하는 명령어 단위 

- CPU에서의 스레드
- 멀티스레드 CPU = 멀티스레드 프로세서: 하나의 코어로 여러 명령어를 동시에 처리하는 CPU
- 하이퍼 스레딩: 인텔의 멀티스레드 기술 

#### 소프트웨어적 스레드 

하나의 프로그램에서 독립적으로 실행되는 단위 

- 프로그래밍 언어나 운영체제에서의 스레드
- 멀티 스레드: 하나의 프로그램에서 여러 부분이 동시에 실행되는 것 

#### 멀티스레드 프로세서 

- 하나의 명령어를 처리하기 위한 필수 레지스터를 여러 개 가지고 있음(프로그램 카운터, 스택 포인터, 데이터 버퍼 레지스터, 데이터 주소 레지스터 등) 

## 2. 명령어 병렬 처리 기법 

명령어를 동시에 처리하여 CPU를 지속적으로 작동시키는 기법 

### 명령어 파이프라인 

동시에 여러 개의 명령어를 겹쳐 실행하는 기법 

```
클럭 단위의 명령어 처리 과정
1. 명령어 인출 Instruction fetch
2. 명령어 해석 Instruction decode
3. 명령어 실행 Execute instruction
4. 결과 저장 Write back
``` 

- 단계가 겹치지 않는다면 CPU는 각 단계를 동시에 실행할 수 있음 

#### 파이프라인 위험 pipeline hazard 

1. 데이터 위험 

- 데이터 의존성에 의해 발생
- 한 명령어의 수행이 끝나야 그 결과에 의해 다음 명령어를 수행할 수 있는 경우 등 

2. 제어 위험 

- 프로그램 카운터의 갑작스러운 변화에 의해 발생
- 분기 등의 경우
- 프로그램 카운터는 현재 실행 중인 명령어의 다음 주소로 갱신되기 때문에 갑작스러운 변화가 생긴다면 명령어 파이프라인에 미리 가지고 와 처리 중이던 명령어들이 쓸모 없어짐
- 분기 예측 branck prediction: 프로그램의 분기를 예측 후 그 주소를 인출하는 기술 

3. 구조적 위험 = 자원 위험 

- 서로 다른 명령어가 동시에 CPU 부품을 사용하려고 할 때 발생
- ALU, 레지스터 등 

### 슈퍼스칼라 

CPU 내부에 여러 개의 명령어 파이프라인을 포함한 구조 

-슈퍼스칼라 CPU = 슈퍼스칼라 프로세서: 슈퍼스칼라 구조로 명령어 처리가 가능한 CPU
- 매 클럭 주기마다 동시에 명령어 인출, 실행이 가능해야 함
- 파이프라인 위험 등의 문제가 있기 때문에 반드시 파이프라인 개수에 비례해 속도가 증가하는 것은 아님 

### 비순차적 명령어 처리 OoOE: Out of Order Execution 

명령어들을 순차적으로 실행하지 않는 기법 

- 순서를 바꿔 실행해도 무방한 명령어를 먼저 실행하여 명령어 파이프라인이 멈추는 것을 방지하는 기법
- CPU가 명령어들의 의존성과 순서 교체 후 실행 가능 여부를 판단할 수 있어야 함 

## CISC, RISC 

### 명령어 집합 ISA 

Instruction Set Architecture
CPU가 이해할 수 있는 명령어들의 모음 

- CPU마다 ISA가 다를 수 있음
- ISA가 다르면 어셈블리어, 제어장치의 명령어 해석 방식, 사용 레지스터 종류와 개수, 메모리 관리 방법 등이 달라짐
- CPU 하드웨어 설계에도 영향을 미침 

### CISC 

Complex Instruction Set Compter
복잡하고 다양한 명령어들을 활용하는 CPU 설계 방식 

장점
- 가변 길이 명령어를 활용: 다양하고 강력한 기능의 명령어 집합을 활용하기 때문에 명령어의 형태와 크기가 다양함
- 상대적으로 적은 수의 명령어로도 프로그램 실행 가능: 메모리 공간 절약 가능 

단점
- 명령어의 크기와 실행되기까지의 시간이 일정하지 않음: 명령어 실행에 여러 클럭 주기를 필요로 함
- 규격화되지 않은 명령어가 파이프라이닝을 어렵게 함
- 실제로 자주 사용되는 명령어의 비율은 적음 

### RISC 

Reduced Instruction Set Computer 

- CISC에 비해 명령어의 종류가 적음
- 고정 길이 명령어 활용: 짧고 규격화된 명령어, 되도록 1클럭 내외로 실행되는 명령어 지향
- 파이프라이닝에 최적화되어 있음
- 메모리 접근을 단순화하고 최소화함: 메모리에 직접 접근하는 명령어는 load와 store뿐
- 레지스터를 적극적으로 활용: 레지스터 이용 연산이 많고 범용 레지스터 개수도 많음